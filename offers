from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.models import Variable
from airflow.utils.dates import days_ago
from airflow.utils.trigger_rule import TriggerRule

import base64
import msal
import requests
import logging
import time
from io import BytesIO

# Biblioteki Azure Form Recognizer
from azure.ai.formrecognizer import DocumentAnalysisClient
from azure.core.credentials import AzureKeyCredential

# Biblioteki do obsługi PDF
from PyPDF2 import PdfReader, PdfWriter

# Biblioteki do generowania Excela
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, NamedStyle

default_args = {
    'owner': 'airflow',
    'depends_on_past': False,
    'retries': 0
}

def safe_field_value(fields_dict, field_name):
    """Bezpiecznie pobiera wartość z wyników OCR (pole 'value')"""
    f = fields_dict.get(field_name)
    if f and isinstance(f, dict):
        raw_val = f.get("value")
        return str(raw_val or "").strip()
    return ""

def parse_table(table_field):
    """
    Parsuje pole 'lista_towar' – wyciąga lp, index, indexklient, nazwa, opakowanie, ilosc,
    cena, cenaoferta, netto, nettoporabacie, brand.
    Pomija wiersze, w których kluczowe pola (lp, index, indexklient, ilosc) są puste.
    """
    rows_result = []
    if table_field and isinstance(table_field, dict):
        items = table_field.get("value")
        if isinstance(items, list):
            for row_item in items:
                if isinstance(row_item, dict):
                    row_dict = row_item.get("value", {})
                    new_row = {
                        "lp": safe_field_value(row_dict, "lp"),
                        "index": safe_field_value(row_dict, "index"),
                        "indexklient": safe_field_value(row_dict, "indexklient"),
                        "nazwa": safe_field_value(row_dict, "nazwa"),
                        "opakowanie": safe_field_value(row_dict, "opakowanie"),
                        "ilosc": safe_field_value(row_dict, "ilosc"),
                        "cena": safe_field_value(row_dict, "cena"),
                        "cenaoferta": safe_field_value(row_dict, "cenaoferta"),
                        "netto": safe_field_value(row_dict, "netto"),
                        "nettoporabacie": safe_field_value(row_dict, "nettoporabacie"),
                        "brand": safe_field_value(row_dict, "brand")
                    }
                    if any(new_row[k].strip() for k in ["lp", "index", "indexklient", "ilosc"]):
                        rows_result.append(new_row)
    return rows_result

def pobierz_token_ms_graph():
    """Uzyskuje token do MS Graph (z Airflow Variables)."""
    tenant_id = Variable.get("offers.tenant_id")
    client_id = Variable.get("offers.client_id")
    client_secret = Variable.get("order.client_secret") 
    authority = f"https://login.microsoftonline.com/{tenant_id}"
    app = msal.ConfidentialClientApplication(
        client_id,
        authority=authority,
        client_credential=client_secret
    )
    result = app.acquire_token_for_client(scopes=["https://graph.microsoft.com/.default"])
    if not result or "access_token" not in result:
        raise Exception("Błąd uwierzytelnienia MS Graph.")
    return result["access_token"]

def wyslij_email_ms_graph(to: str, temat: str, tresc_html: str, zalaczniki: list = None):
    """Wysyła e-mail (HTML) przez MS Graph."""
    token = pobierz_token_ms_graph()
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    email_account = Variable.get("offers.konto_email")
    url = f"https://graph.microsoft.com/v1.0/users/{email_account}/sendMail"
    dane_email = {
        "message": {
            "subject": temat,
            "body": {"contentType": "HTML", "content": tresc_html},
            "toRecipients": [{"emailAddress": {"address": to}}]
        },
        "saveToSentItems": "true"
    }
    if zalaczniki:
        dane_email["message"]["attachments"] = zalaczniki
    resp = requests.post(url, headers=headers, json=dane_email)
    if resp.status_code not in (200, 202):
        raise Exception(f"Błąd wysyłania e-maila: {resp.status_code} {resp.text}")
    logging.info("Wysłano e-mail do %s", to)

def podziel_pdf(pdf_bajty: bytes) -> list:
    """Dzieli PDF na strony (jako bajty)."""
    reader = PdfReader(BytesIO(pdf_bajty))
    strony = []
    for i in range(len(reader.pages)):
        writer = PdfWriter()
        writer.add_page(reader.pages[i])
        buff = BytesIO()
        writer.write(buff)
        buff.seek(0)
        strony.append(buff.read())
    return strony

def analizuj_strone(client: DocumentAnalysisClient, model_id: str, dokument: bytes, max_retries: int = 3):
    """
    Analizuje pojedynczą stronę/obraz za pomocą Form Recognizer (retry do max_retries).
    Zwraca result.to_dict().
    """
    attempt = 0
    while attempt < max_retries:
        attempt += 1
        try:
            poller = client.begin_analyze_document(model_id=model_id, document=BytesIO(dokument))
            result = poller.result()
            return result.to_dict()
        except Exception as e:
            logging.warning("Analiza OCR – próba %d nieudana: %s", attempt, str(e))
            time.sleep(5)
    raise Exception("Przekroczono limit prób analizy strony.")

def pobierz_wiadomosci(**kwargs):
    logging.info("Rozpoczynam pobieranie wiadomości e-mail...")
    token = pobierz_token_ms_graph()
    email_account = Variable.get("offers.konto_email")
    folder = Variable.get("offers.folder_poczta", default_var="Inbox")
    headers = {"Authorization": f"Bearer {token}"}
    url = (
        f"https://graph.microsoft.com/v1.0/users/{email_account}/mailFolders/{folder}/messages?"
        "$filter=isRead eq false and hasAttachments eq true&$top=2"
    )
    r = requests.get(url, headers=headers)
    if r.status_code != 200:
        raise Exception(f"Błąd pobierania maili: {r.status_code}, {r.text}")
    maile = r.json().get("value", [])
    if not maile:
        logging.info("Brak nowych wiadomości do przetworzenia.")
        return []
    dozwolone_typy = ["application/pdf", "image/jpeg", "image/jpg", "image/png", "image/bmp"]
    out = []
    for mail in maile:
        msg_id = mail.get("id")
        sender = mail.get("from", {}).get("emailAddress", {}).get("address")
        logging.info("Znaleziono mail ID=%s, od=%s", msg_id, sender)
        # przeniesienie do inprogress
        folder_inprogress = Variable.get("offers.folder_inprogress")
        move_url = f"https://graph.microsoft.com/v1.0/users/{email_account}/messages/{msg_id}/move"
        move_resp = requests.post(move_url, headers={**headers, "Content-Type": "application/json"},
                                  json={"destinationId": folder_inprogress})
        if move_resp.status_code in (200, 201):
            msg_id = move_resp.json().get("id", msg_id)
        else:
            logging.warning("Nie udało się przenieść maila ID=%s do inprogress.", msg_id)
        # pobranie załączników
        attach_url = f"https://graph.microsoft.com/v1.0/users/{email_account}/messages/{msg_id}/attachments"
        aresp = requests.get(attach_url, headers=headers)
        if aresp.status_code != 200:
            logging.error("Błąd pobierania załączników maila ID=%s: %s", msg_id, aresp.text)
            continue
        attachments = aresp.json().get("value", [])
        dobre_pliki = []
        for att in attachments:
            ctype = att.get("contentType", "")
            # odrzucamy inline (np. stopki) oraz bierzemy tylko dozwolone typy
            if not att.get("isInline", False) and ctype in dozwolone_typy and att.get("contentBytes"):
                dobre_pliki.append({
                    "nazwa": att.get("name"),
                    "zawartosc": att.get("contentBytes")
                })
        if not attachments:
            wyslij_email_ms_graph(to=sender, temat="Brak załącznika",
                                   tresc_html="Nie wykryto załącznika. Prosimy o przesłanie oferty w formacie PDF/obraz.")
        elif attachments and not dobre_pliki:
            wyslij_email_ms_graph(to=sender, temat="Błędny format załącznika",
                                   tresc_html="Załączony plik nie jest w obsługiwanym formacie (PDF, JPG, JPEG, PNG, BMP).")
        else:
            out.append({"msg_id": msg_id, "sender": sender, "zalaczniki": dobre_pliki})
    return out

def analizuj_dokumenty(**kwargs):
    ti = kwargs["ti"]
    maile = ti.xcom_pull(task_ids="pobierz_maile")
    if not maile:
        logging.info("Brak maili do analizy.")
        return []
    fr_endpoint = Variable.get("offers.fr_endpoint")
    fr_key = Variable.get("offers.fr_key")
    model_id = Variable.get("offers.model_id")
    client = DocumentAnalysisClient(fr_endpoint, AzureKeyCredential(fr_key))
    wyniki = []
    for mail in maile:
        sender = mail["sender"]
        for zal in mail["zalaczniki"]:
            nazwa = zal["nazwa"]
            file_bytes = base64.b64decode(zal["zawartosc"])
            strony = podziel_pdf(file_bytes) if nazwa.lower().endswith(".pdf") else [file_bytes]
            analizy_stron = []
            for idx, s in enumerate(strony, start=1):
                try:
                    analizy_stron.append(analizuj_strone(client, model_id, s))
                except Exception as e:
                    logging.error("Błąd analizy str. %d pliku %s: %s", idx, nazwa, str(e))
            static_fields = {}
            lista_pozycji = []
            if analizy_stron:
                docs_first = analizy_stron[0].get("documents", [])
                if docs_first:
                    f = docs_first[0].get("fields", {})
                    static_fields = {
                        "Numer": safe_field_value(f, "Numer"),
                        "nazwa": safe_field_value(f, "nazwa"),
                        "wazna": safe_field_value(f, "wazna"),
                        "ilosc": safe_field_value(f, "ilosc"),
                        "klient": safe_field_value(f, "klient"),
                        "wartosc_netto": safe_field_value(f, "wartosc_netto"),
                        "wartosc_brutto": safe_field_value(f, "wartosc_brutto"),
                        "rabat": safe_field_value(f, "rabat"),
                        "placowka": safe_field_value(f, "placowka"),
                        "budowa": safe_field_value(f, "budowa"),
                        "autor_nazwa": safe_field_value(f, "autor_nazwa"),
                        "autor_telefon": safe_field_value(f, "autor_telefon"),
                        "autor_mail": safe_field_value(f, "autor_mail"),
                    }
            for page in analizy_stron:
                for doc in page.get("documents", []):
                    if "lista_towar" in doc.get("fields", {}):
                        lista_pozycji.extend(parse_table(doc["fields"]["lista_towar"]))
            wyniki.append({
                "sender": sender,
                "zalacznik": nazwa,
                "static_fields": static_fields,
                "lista_pozycji": lista_pozycji
            })
    return wyniki

def generuj_excels(**kwargs):
    ti = kwargs['ti']
    data = ti.xcom_pull(task_ids='analizuj_dokumenty')
    if not data:
        logging.info('Brak danych do generowania XLSX.')
        return []

    excels = []

    for rec in data:
        rows = rec['lista_pozycji']

        # 1) listapozycji.xlsx (bez zmian)
        wb1 = Workbook()
        ws1 = wb1.active; ws1.title = 'ListaPozycji'
        headers1 = ['NR', 'index', 'indexklient', 'nazwa', 'opakowanie',
                    'ilosc', 'cena', 'cenaoferta', 'netto', 'nettoporabacie', 'brand']
        num_style = NamedStyle(name='num_style', number_format='0.00')
        if 'num_style' not in wb1.named_styles:
            wb1.add_named_style(num_style)
        for i, h in enumerate(headers1, start=1):
            c = ws1.cell(row=1, column=i, value=h)
            c.font = Font(bold=True)
            c.alignment = Alignment(horizontal='center')
        numeric_cols = {'ilosc', 'cena', 'cenaoferta', 'netto', 'nettoporabacie'}
        for r, row in enumerate(rows, start=2):
            for c_idx, h in enumerate(headers1, start=1):
                if h == 'NR':
                    ws1.cell(row=r, column=c_idx, value=r-1)
                else:
                    v = row.get(h, '')
                    if h in numeric_cols:
                        # usuwamy wszystkie przecinki przed konwersją
                        clean = v.replace(',', '')
                        try:
                            num = float(clean)
                        except:
                            num = 0.0
                        cell = ws1.cell(row=r, column=c_idx, value=num)
                        cell.style = 'num_style'
                    else:
                        ws1.cell(row=r, column=c_idx, value=v)
        buf1 = BytesIO(); wb1.save(buf1)
        b64_list = base64.b64encode(buf1.getvalue()).decode()

        # 2) import.xlsx (zmienione nagłówki)
        wb2 = Workbook()
        ws2 = wb2.active; ws2.title = 'import'
        headers2 = ['KOD PRODUKTU', 'KOD EAN', 'KOD KLIENTA', 'ILOSC']
        num_imp = NamedStyle(name='num_style_imp', number_format='0.00')
        if 'num_style_imp' not in wb2.named_styles:
            wb2.add_named_style(num_imp)
        for i, h in enumerate(headers2, start=1):
            c = ws2.cell(row=1, column=i, value=h)
            c.font = Font(bold=True)
            c.alignment = Alignment(horizontal='center')
        rownum = 2
        for row in rows:
            if not any(row.get(k, '').strip() for k in ['index', 'indexklient', 'ilosc']):
                continue
            ws2.cell(row=rownum, column=1, value=row.get('index', ''))
            ws2.cell(row=rownum, column=2, value='')
            ws2.cell(row=rownum, column=3, value=row.get('indexklient', ''))
            # usuwamy przecinki przed konwersją ILOSCI
            ilo_raw = row.get('ilosc', '')
            clean_ilo = ilo_raw.replace(',', '')
            try:
                ilo = float(clean_ilo)
            except:
                ilo = 0.0
            c = ws2.cell(row=rownum, column=4, value=ilo)
            c.style = 'num_style_imp'
            rownum += 1
        buf2 = BytesIO(); wb2.save(buf2)
        b64_imp = base64.b64encode(buf2.getvalue()).decode()

        excels.append({
            'excel_listapozycji_b64': b64_list,
            'excel_import_b64': b64_imp
        })

    return excels

def wyslij_wynik(**kwargs):
    ti = kwargs["ti"]
    data = ti.xcom_pull(task_ids="analizuj_dokumenty")
    excels = ti.xcom_pull(task_ids="generuj_excels")
    if not data:
        logging.info("Brak danych do wysyłki.")
        return

    for rec, excel in zip(data, excels):
        sender    = rec["sender"]
        static    = rec["static_fields"]
        lista     = rec["lista_pozycji"]
        zalacznik = rec["zalacznik"]
        html = """
<html><body style="font-family: Aptos,sans-serif;">
  <h3 style="font-size:11px;margin-bottom:5px;">Podsumowanie zamówienia</h3>
  <table style="border-collapse:collapse;width:100%;margin-bottom:20px;">
    <tr><th style="border:1px solid #ccc;padding:4px;font-size:11px;">Nazwa pola</th>
        <th style="border:1px solid #ccc;padding:4px;font-size:11px;">Wartość</th></tr>"""
        for k,v in static.items():
            html += f"""<tr><td style="border:1px solid #ccc;padding:4px;font-size:11px;">{k}</td>
                          <td style="border:1px solid #ccc;padding:4px;font-size:10px;">{v}</td></tr>"""
        html += """
  </table>
  <h3 style="font-size:11px;margin-bottom:5px;">Lista towarów</h3>
  <table style="border-collapse:collapse;width:100%;">
    <tr>
      <th style="border:1px solid #ccc;padding:4px;font-size:11px;">LP</th>
      <th style="border:1px solid #ccc;padding:4px;font-size:11px;">KOD KLIENTA</th>
      <th style="border:1px solid #ccc;padding:4px;font-size:11px;">KOD PRODUKTU</th>
      <th style="border:1px solid #ccc;padding:4px;font-size:11px;">NAZWA PRODUKTU</th>
      <th style="border:1px solid #ccc;padding:4px;font-size:11px;">OPAKOWANIE</th>
      <th style="border:1px solid #ccc;padding:4px;font-size:11px;text-align:right;">ILOSC</th>
      <th style="border:1px solid #ccc;padding:4px;font-size:11px;text-align:center;">MARKA</th>
    </tr>"""
        for row in lista:
            html += f"""
    <tr>
      <td style="border:1px solid #ccc;padding:4px;font-size:10px;">{row.get('lp','')}</td>
      <td style="border:1px solid #ccc;padding:4px;font-size:10px;">{row.get('indexklient','')}</td>
      <td style="border:1px solid #ccc;padding:4px;font-size:10px;">{row.get('index','')}</td>
      <td style="border:1px solid #ccc;padding:4px;font-size:10px;">{row.get('nazwa','')}</td>
      <td style="border:1px solid #ccc;padding:4px;font-size:10px;">{row.get('opakowanie','')}</td>
      <td style="border:1px solid #ccc;padding:4px;font-size:10px;text-align:right;">{row.get('ilosc','')}</td>
      <td style="border:1px solid #ccc;padding:4px;font-size:10px;text-align:center;">{row.get('brand','')}</td>
    </tr>"""
        html += "</table></body></html>"

        attachments = []
        if excel.get("excel_listapozycji_b64"):
            attachments.append({
                "@odata.type": "#microsoft.graph.fileAttachment",
                "name": "listapozycji.xlsx",
                "contentBytes": excel["excel_listapozycji_b64"],
                "contentType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            })
        if excel.get("excel_import_b64"):
            attachments.append({
                "@odata.type": "#microsoft.graph.fileAttachment",
                "name": "import.xlsx",
                "contentBytes": excel["excel_import_b64"],
                "contentType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            })

        wyslij_email_ms_graph(
            to=sender,
            temat=f"Wynik analizy załącznika: {zalacznik}",
            tresc_html=html,
            zalaczniki=attachments
        )

def oznacz_przetworzone(**kwargs):
    ti = kwargs["ti"]
    maile = ti.xcom_pull(task_ids="pobierz_maile")
    if not maile:
        logging.info("Brak maili do oznaczenia.")
        return
    token = pobierz_token_ms_graph()
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    email_account = Variable.get("offers.konto_email")
    end_folder = Variable.get("offers.folder_end")
    for m in maile:
        msg_id = m["msg_id"]
        move_url = f"https://graph.microsoft.com/v1.0/users/{email_account}/messages/{msg_id}/move"
        r = requests.post(move_url, headers=headers, json={"destinationId": end_folder})
        if r.status_code in (200,201):
            msg_id = r.json().get("id", msg_id)
        # oznacz jako przeczytane
        patch_url = f"https://graph.microsoft.com/v1.0/users/{email_account}/messages/{msg_id}"
        requests.patch(patch_url, headers=headers, json={"isRead": True})

with DAG(
    dag_id='przetwarzanie_ofert4.0',
    default_args=default_args,
    description='DAG: pobiera e-maile, analizuje załączniki, generuje XLSX i wysyła e-mail',
    schedule_interval='* * * * *',
    start_date=days_ago(1),
    catchup=False,
    max_active_runs=1,
    concurrency=2,
    tags=["ai_prod"]
) as dag:

    pobierz_task = PythonOperator(
        task_id="pobierz_maile",
        python_callable=pobierz_wiadomosci,
        pool="sprawdzenie_maili"
    )

    analizuj_task = PythonOperator(
        task_id="analizuj_dokumenty",
        python_callable=analizuj_dokumenty
    )

    generuj_excels_task = PythonOperator(
        task_id="generuj_excels",
        python_callable=generuj_excels
    )

    wyslij_task = PythonOperator(
        task_id="wyslij_wynik",
        python_callable=wyslij_wynik,
        trigger_rule=TriggerRule.ALL_SUCCESS
    )

    oznacz_task = PythonOperator(
        task_id="oznacz_przetworzone",
        python_callable=oznacz_przetworzone
    )

    pobierz_task >> analizuj_task >> generuj_excels_task >> wyslij_task >> oznacz_task
